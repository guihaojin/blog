---
layout: post
title: 我为什么喜欢Ruby
description: ""
category:
tags: [ruby]
---
{% include JB/setup %}

工作一年多以来，最开心的事情之一就是学习跟使用[Ruby](https://www.ruby-lang.org/en/)了。作为一个半路出家的程序猿，我前前后后也接触了不少语言，最早的时候的C，然后在学校的时候主要是鼓捣C++, Java, 后来还自学过一点Python, Go跟一些函数式语言，如ML，Scheme。到目前为止，我最喜欢也是使用最多的就是Ruby了。下面就来说说Ruby为何如此吸引人。

##### 一点历史
Ruby是一位叫做松本行弘的日本程序员发明的，动态的，面向对象的通用编程语言。发明Ruby时的出发点是“以人为本”，注重简洁和高效，从而让程序员能快乐地编程，而不只是感觉面对冰冷的机器跟一行行代码。从这一点上来讲我认为Ruby是成功的。因为从我和身边的一些人的经验来看，Ruby编程的确给我们带来了很多的快乐。

##### 一些澄清
首先，我不想挑起编程语言之争，语言之间没有绝对的孰优孰劣，选择合适的最重要。我说我最喜欢Ruby，你说凤姐最漂亮，这些都是基本的自由。Ruby当然有它的缺点，但是这并不妨碍它成为一种优秀的语言。而且我还会拿它与另一个极受欢迎的语言Python做一些比较，其实我也是很喜欢Python的，拿来做比较只是为了突出Ruby的一些特点而已。

另外，说到Ruby很多人就联想到了RoR(Ruby on Rails)。RoR是用Ruby开发的一个非常流行的Web开发框架，应该说RoR对Ruby的流行起到了很好地促进作用，但是Ruby本身是一个通用编程语言，并不是只能开发Web。例如，我日常的主要工作就是用Ruby做分布式系统的开发，完全没有用到RoR。有人听到这里就会问，那不是很慢么？这个对也不对，Ruby跟很多语言相比是要“慢”一些，但是因为系统的瓶颈是I/O，所以用Ruby带来的性能下降是可以忽略不计的，再算上开发效率跟工作心情上的提升，可以说用Ruby是一个很不错的选择。本文要讨论的是Ruby语言本身，而不是RoR。

##### 下面就进入正题吧！

###### Ruby的一些不那么突出的特点：
* **简洁的脚本语言**

使用过C++/Java这些编译型语言跟php, python, ruby这些脚本语言完成过一些基本的文本处理之类的任务人不难发现脚本语言的方便之处。概括起来脚本语言的方便之处主要有2点：

1. 编译跟执行在一起，改完了直接run，不用再重新编译；
2. 2.没有麻烦的入口函数/main函数之类的东西，一行行执行，简单明了；

这些也是脚本语言跟编译语言的最大不同。同时，作为一种高度抽象化的编程语言，Ruby程序非常简洁，不用怎么考虑内存管理，垃圾回收等底层的问题，不用声明变量类型，可以省略语句结束的分号跟参数列表的括号，不用写return等等...为了说明Ruby的简洁，就来看看《松本行弘的程序世界》这本书中的一个例子吧：分别用Java跟Ruby实现斐波那契数列。

Java版本：

	class Sample {
		private static int fib(int n) {
			if (n < 2) {
				return n;
			}
			else {
				return fib(n - 1) + fib(n - 2);
			}
		}
		public static void main(String[] argv) {
			System.out.println("fib(6)=" + fib(6));
		}
	}

Ruby版本：

	def fib(n)
		if n < 2
			n
		else
			fib(n - 1) + fib(n - 2)
		end
	end
	print "fib(6)=", fib(6), "\n"
	
当然这个程序用Python实现会更简洁因为连那两个end行都可以省略。有些人喜欢Python那种用缩进来表示代码块的方式，但是我个人并不那么喜欢，因为一旦程序的逻辑复杂了，就容易弄错缩进的层次。我自己有几次都是由于没有注意到这种缩进而写出了逻辑上不是我想要的Python程序。同时Python的缩进用tab跟空格不一样有时候也让人有点恼火。

* **irb**

Ruby的命令行交互工具irb(Interactive Ruby Shell)非常方便。我自己平时在Terminal中永远会留一个Tab给irb，这样可以随时做运算，验证一些想法，而且因为是REPL(read-evaluate-print-loop)，所以可以在上面反复试验并马上看得到每一个语句的结果。在Ruby之前我曾用过Python的命令行工具，不得不说比起irb，Python的用户体验就要差了一截。我想可能跟Ruby里所有的语句都是表达式有关系吧。顺便说一句，Python有个项目叫[ipython](http://ipython.org/),目的大概是想达到跟irb相当的效果。

* **语法的优雅跟人性化**

Ruby是我目前见过的最纯粹面向对象语言，而且Ruby在面相对象编程时候的思想也是我非常欣赏的。首先，Ruby中几乎所有的东西都是对象，没有像Java或者其它语言里面的所谓基本数据类型。有些人觉得奇怪，好像Ruby里也是有1+2这样的表达式的啊。没错，但是在Ruby中，1是一个对象，1+2实际上是1这个对象调用了.+() 这个方法，2是参数。如果不信，可以打开irb，运行1.class，结果是Fixnum，表示1是Fixnum这个类的对象。还不信？那就在irb里输入1.methods,结果是一个Symbol的数组（太长就不在这里贴出来），这是所有可以在1这个对象上调用的方法。其中有一个是:+,也就是整数的加法了。最后还可以试试输入1.+(2)或者1.+ 2(Ruby的括号可以省略)看看结果是不是一样。正是因为有了纯粹的面相对象，所以Ruby里的所有语句都是方法调用，即使是puts(Ruby的print)语句。这样一来Ruby也有了更好地统一性，几乎任何时候，任何操作都是在执行方法，就不会像Python里，一会儿是array.append(x), 一会儿又是del array(x)，Java等语言就更不提了。Ruby里对Array的操作永远是Array#method(调用Array对象的method方法)。Ruby的语法的人性化在于当你想要一个Ruby的方法的时候，它往往就在那里了。比如说你想要翻转数组，就有Array#reverse这样的方法。顺便再吐槽一下Python。当有一天我翻了半天文档发现Python的array里面竟然没有一个类似于reverse的方法，而是要用array[::-1]这样丑陋的方式的时候，当时是真的有点小小的失望。(Python迷们别拍我哈，我对Python的理解太浅:-)) 当你想要一个获得数组里所有不同的元素的时候，Ruby就有Array#uniq(unique的缩写）这样的方法。当你想找在一个数组中而不在另个数组中的元素的时候，Ruby就有array_1 - array_2这样的方法来实现。这不就是是“众里寻他千百度，蓦然回首，方法就在灯火阑珊处“么？呵呵。老实说，这些方法没有什么大不了的，实现以下也不难，但是谁说这不是在细节上体现了语言的贴心之处呢。再说Ruby中的面相对象编程，在设计Ruby的类的时候，所有的instance variable(实例变量)都是private的，而且只能是private。这一点上Ruby的不妥协是对面相对象的封装性很好的诠释。有些人可能因此担心那岂不是要像Java一样写很多的getter,setter。这个Ruby早就为程序猿想好了，在类里面，一行

	attr_reader :x, :y, :z

就定义了三个getter方法，分别是get_x, get_y和get_z, 而一行

	attr_accessor :x, :y, :z
	
则定义了六个方法，分别是get_x, get_y, get_z和set_x(x), set_y(y), set_z(z)。有点神奇吧。:-) 当然对Ruby而言这根本不算什么。

#### Ruby真正的杀手锏

我觉得以上的东西对Ruby而言很重要，但是都是不是Ruby真正让人尖叫的地方。Ruby真正让我刮目相看的是它的开放性，程序块(block)以及其它对函数式编程的有力支持的特性。

Ruby到底有多开放呢？基本上来说，Ruby里地所有的类都是可以随时添加新的内容的。什么意思呢？比如说Ruby有Array类，但是没有一个叫做qi_pa的方法。这个时候，我们可以“打开”Ruby的Array类，定义一个叫qi_pa的方法，代码大致如下，就为Array添加了一个qi_pa方法。以后你的数组对象都可以调用这个qi_pa方法了。

	class Array
		def qi_pa
			print "我在Ruby的Array类里定义了一个奇葩方法，好神奇哦！"
		end
	end

除了添加方法以外，还可以用重新定义方法或者用undef_method把方法"消灭“掉。这些都算是猴子补丁吧，在Ruby里面特别容易实现，同时也是一把双刃剑。

**程序块**(Block)是Ruby的最大特点之一。一开始的时候程序块只是设计用来处理循环的。

	[1, 2, 3, 4, 5].each { |x| print x }

以上是Ruby里遍历一个数组的最常见方法，意思是遍历数组里的所有元素，挨个打印出来。each后面的大括号里面的部分就是一个Ruby的程序块(多行的时候一般用do...end取代{...})。从这个最简单的例子就可以看到，Ruby的程序块省去了for(int i; i < length; i++)这些不必要而且可能犯错的东西，让我们专注于循环本身。同时还可以用它来写出一些非常规的控制结构。比如说循环10次在Ruby里就可以写成这样:

	10.times { print "wo shi sb" }

当然这些也不算什么，Ruby程序块最大的好处是可以把它当做函数参数实现函数式编程里的高阶函数，加上它有闭包的特性所以用程序块本质上跟高阶函数就没有什么区别了。举两个简单地例子:

	["aa", "b", "ccc"].sort_by { |x| x.size }

这是对字符串数组进行排序，后面的程序块可以看做是一个定义排序规则的函数。

	[1, 2, 3, 4, 5].select { |x| x % 2 == 0 }.map { |x| x.to_s }

这个例子是先select(找出)可以被2整除的所有元素，然后map(映射)成所有的数字的字符串(.to_s方法实现)的array。而且我还可以在后面继续添加任意多我想要做的处理。从这里是不是能够稍微感受到Ruby的表达力有多强呢。:-) 程序块的妙用远不止于此，这里就只是抛砖引玉了。

Ruby的开放性，反射性跟灵活性使得这个语言成为一个非常容易拿来做元编程(metaprogramming)的语言，也可以非常方便地写特定领域语言(Domain-Specific Language),简称DSL。流行的Ruby框架Raisl的就大量的使用了元编程的技巧，它也可以说是Ruby的一个DSL。同时现在有一个越来越流行的工具叫做[Chef](http://www.getchef.com/chef/)，主要用来做服务器自动化跟部署等工作，也是Ruby写的DSL。下面是Ruby元编程的一个简单地例子,同样来自《松本行弘的程序世界》,自己来实现前面提到过的attr_accessor:

	class Module
		def attr_accessor(*args)
			args.each do |arg|
				class_eval %{
					def #{arg}
						@#{arg}
					end
					def #{arg}=(value)
						@#{arg}=value
					end
				}
			end
		end
	end

简单地解释一下我们在这里干了些什么。首先是打开了Module这个类，我们定义的类都包含了它，所以也就有了attr_accessor这个方法。*args表示参数的个数可变，然后对每个参数，定义了一个getter跟setter方法。这样我们自己定义的方法只要加上attr_accessor :a, :b, :c就自动有了3个getter和3个setter方法。

有人问函数式编程跟元编程有什么用呢？我自己也是这方面的初学者，个人以为一个很重要的好处就是它们经常能实现更高层次的抽象，抽象带来的结果是往往程序更简洁，更健壮，更容易维护。说到底编程就是跟复杂性还有bug的斗争。程序越是简洁，出错的可能性自然就更小。

##### Ruby为人诟病的地方

Ruby并不是十全十美，我也听到并认识到它的一些不足。第一，Ruby的性能，无论是速度还是资源占用，在流行的编程语言中确实不怎么样。所以在有些性能要求很高的地方，Ruby就不是那么合适，当然我觉得以当今的计算机性能，绝大多数时候Ruby的性能都是绰绰有余的。第二，Ruby解决同一个问题往往会有多种方法，这种思想据说是继承了Perl。这样导致即使是同一个问题，不同的人写出来的Ruby程序都不一样，跟Python那种用一种方法解决一个问题的思想截然相反。有些人很不喜欢这一点，但是我个人倒是无所谓。我觉得更重要的一个问题是由于Ruby的灵活跟强大，不好好使用的时候会造成非常坏的结果，比如说打开类，猴子补丁。正所谓能力越大，责任越大。值得一提的另外一点是Ruby并不是为了大规模并行计算而生，而这一点也是未来的服务器端语言越来越看重的地方。Ruby想要在服务器端继续占有一席之地的话可能需要在这方面有所改进。不过Ruby的一些事件驱动模型的库，比如说Eventmachine(我们的系统就在使用)，也是很强大的。

##### 结束的话

说了这么多,也是对学习Ruby的一个小小的总结吧。Ruby容易上手，但它并不是一个简单的语言，我自认为还有很多地方需要学习。文中的很多东西是自己的一些拙见，不一定对，欢迎各位拍砖指正。